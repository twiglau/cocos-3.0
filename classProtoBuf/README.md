# 客户端与服务器数据通讯全流程  

```
用户发送数据结构 =>   Json协议数据编码  => 服务号|命令号  =>  加密数据包 
                   --------------
                   Buf 协议数据编码
                
=>   Websocket封包   =>  网络发送   =>  网络接收  =>   Websocket 解包
     -----------                                    ------------
     TCP封包                                        TCP 解包

=> 解密数据包 =>
    
=>   服务号|命令号 | 数据body   =>   数据解码           => 获取数据结构
                                 
                             =>   Buf 协议数据解码
```

- 不同编程语言的数据对象 => 序列化 => 二进制化 (protoBuf协议, 或变种)  | 文本化:(数据对象 => json数据文本, xml数据文本)  
- 会在序列化数据以后, 打上标识:[服务号(2个字节), 命令号(2个字节)] 
> 只有有了标识 => 是用哪种方式去对待这个数据;
> 为什么需要两个标识: 需要做, 网关 => 命令 => 对应的服务器上; => 这个服务器根据服务号,命令号,识别是哪个请求;
> 封包? 
>> 因为TCP是可靠传送协议, 发一个数据包过去 => 回应 => 再发下一个数据包;
>> TCP底层: 等更多的数据一起发过去, "blake"  "bycw"  => "blakeycw" 粘包问题;
>> TCP 会处理 => 分包拆包 [size, 数据内容, 校验];
>> H5 简化这个东西 => Websocket协议 => 分包拆包协议;  
> WebSocket是什么?
>> 底层基于TCP的, 实现了TCP封包,拆包问题的一种协议;  
>> 连接协议, 关闭协议, 发送数据的协议, 接受数据的协议;

- TCP + 自定义封包拆包协议 + protobuf序列化工具; 
- [WebSocket] + protobuf 系列化工具; Creator H5, android, iOS websocket => native实现; 服务器也要支持 Websocket;  

# Creator 框架如何展开?  
# Protobuf 的配置与导入到 Creator
1. 协议定义工具;
2. 序列化/反序列化 => 编码解码的库 => runtime;
3. 还有一个工具: 编译工具 => 协议 => 目标语言的代码: C++, Java;
4. JavaScript是不一样的 => 加载协议文件 => 解析协议文件 => 运行的时候我们来动态的生成出来; 
- 需要: runtime库
- 需要: 协议文件, runtime库直接加载协议文件就可以了;

5. 举例: 
- 发送用户登录数据, 先 new GuestLoginReq 对象出来, 初始化数据;
- 调用接口将 对象 => 序列化 => 二进制  
6. 步骤:
- 制定协议文件:game.proto;
- 需要编码解码的 runtime库;作为插件,允许应用导入;
7. 导入插件 runtime库后, protobuf 变量不识别,可以在 `creator.d.ts` 文件中定义变量: 
```
/** 自定义些变量, 让编译器识别 */
declare const protobuf: any;

```
# WebSocket 的使用详解
1. WebSocket 有那两种模式?  binaryType  
- 
# 与服务器的命令对接过程详解



